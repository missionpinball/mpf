<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mpf.system.light_controller module &mdash; Mission Pinball Framework 0.20.0-a0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.20.0-a0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Mission Pinball Framework 0.20.0-a0 documentation" href="index.html" />
    <link rel="up" title="mpf.system package" href="mpf.system.html" />
    <link rel="next" title="mpf.system.logic_blocks module" href="mpf.system.logic_blocks.html" />
    <link rel="prev" title="mpf.system.events module" href="mpf.system.events.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mpf.system.logic_blocks.html" title="mpf.system.logic_blocks module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mpf.system.events.html" title="mpf.system.events module"
             accesskey="P">previous</a> |</li>
        <li><a href="mpf.html">Mission Pinball Framework 0.20.0-a0 documentation</a> &raquo;</li>
          <li><a href="mpf.system.html" accesskey="U">mpf.system package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-mpf.system.light_controller">
<span id="mpf-system-light-controller-module"></span><h1>mpf.system.light_controller module</h1>
<p>Manages the light shows in a pinball machine.</p>
<dl class="class">
<dt id="mpf.system.light_controller.LightController">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">LightController</tt><big>(</big><em>machine</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Manages all the light shows in a pinball machine.</p>
<p>&#8216;light shows&#8217; are coordinated light, flasher, coil, and event effects.
The LightController handles priorities, restores, running and stopping
Shows, etc. There should be only one per machine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>machine</strong> &#8211; Parent machine object.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mpf.system.light_controller.LightController.add_light_player_show">
<tt class="descname">add_light_player_show</tt><big>(</big><em>event</em>, <em>settings</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.create_show_from_script">
<tt class="descname">create_show_from_script</tt><big>(</big><em>script</em>, <em>lights=None</em>, <em>leds=None</em>, <em>light_tags=None</em>, <em>led_tags=None</em>, <em>key=None</em><big>)</big></dt>
<dd><p>Creates a light show from a script.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>script</strong> &#8211; Python dictionary in MPF light script format</li>
<li><strong>lights</strong> &#8211; String or iterable of multiples strings of the matrix lights
that will be included in this show.</li>
<li><strong>leds</strong> &#8211; String or iterable of multiples strings of the LEDs that will
be included in this show.</li>
<li><strong>light_tags</strong> &#8211; String or iterable of multiples strings of tags of
matrix lights that specify which lights will be in this show.</li>
<li><strong>led_tags</strong> &#8211; String or iterable of multiples strings of tags of
LEDs that specify which lights will be in this show.</li>
<li><strong>key</strong> &#8211; Object (typically string) that will be used to stop the show
created by this list later.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mpf.system.light_controller.LightController.current_time">
<tt class="descname">current_time</tt><em class="property"> = None</em></dt>
<dd><p>The light controller uses a common system time for the entire show system so that every
&#8220;current_time&#8221; of a single update cycle is the same everywhere. This
ensures that multiple shows, scripts, and commands start in-sync
regardless of any processing lag.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mpf.system.light_controller.LightController.hexstring_to_int">
<em class="property">static </em><tt class="descname">hexstring_to_int</tt><big>(</big><em>inputstring</em>, <em>maxvalue=255</em><big>)</big></dt>
<dd><p>Takes a string input of hex numbers and an integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_string</strong> &#8211; A string of incoming hex colors, like ffff00.</li>
<li><strong>maxvalue</strong> &#8211; Integer of the max value you&#8217;d like to return. Default is
255. (This is the real value of why this method exists.)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Integer representation of the hex string.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="mpf.system.light_controller.LightController.hexstring_to_list">
<em class="property">static </em><tt class="descname">hexstring_to_list</tt><big>(</big><em>input_string</em>, <em>output_length=3</em><big>)</big></dt>
<dd><p>Takes a string input of hex numbers and returns a list of integers.</p>
<p>This always groups the hex string in twos, so an input of ffff00 will
be returned as [255, 255, 0]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>input_string</strong> &#8211; A string of incoming hex colors, like ffff00.</li>
<li><strong>output_length</strong> &#8211; Integer value of the number of items you&#8217;d like in
your returned list. Default is 3. This method will ignore
extra characters if the input_string is too long, and it will
pad with zeros if the input string is too short.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">List of integers, like [255, 255, 0]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.load_shows">
<tt class="descname">load_shows</tt><big>(</big><em>path</em><big>)</big></dt>
<dd><p>Automatically loads all the light shows in a path.</p>
<p>Light shows are added to the dictionary self.shows with they key
set to the value of the file name.</p>
<p>For example, the light show &#8216;sweep.yaml&#8217; will be loaded as
self.shows[&#8216;sweep&#8217;]</p>
<p>This method will also loop through sub-directories, allowing the game
programmer to organize the light show files into folders as needed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; A string of the relative path to the folder, based from the
root from where the mpf.py file is running.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.play_show">
<tt class="descname">play_show</tt><big>(</big><em>show</em>, <em>priority=0</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Plays a light show.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>show</strong> &#8211; Either the string name of a registered show or a direct
reference to the show object you want to play.</li>
<li><strong>priority</strong> &#8211; The priority this show will play at.</li>
<li><strong>**kwargs</strong> &#8211; Contains the parameters and settings to control the
playing of the show. See Show.play() for options and details.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.process_light_player">
<tt class="descname">process_light_player</tt><big>(</big><em>config</em>, <em>mode=None</em>, <em>priority=0</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.process_light_scripts">
<tt class="descname">process_light_scripts</tt><big>(</big><em>config</em>, <em>mode=None</em>, <em>priority=0</em><big>)</big></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mpf.system.light_controller.LightController.queue">
<tt class="descname">queue</tt><em class="property"> = None</em></dt>
<dd><p>A list of dicts which contains things that need to be serviced in the
future, including: (ot all are always used)</p>
<blockquote>
<div><ul class="simple">
<li>lightname</li>
<li>priority</li>
<li>blend</li>
<li>fadeend</li>
<li>dest_color</li>
<li>color</li>
<li>playlist</li>
<li>action_time</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.restore_lower_lights">
<tt class="descname">restore_lower_lights</tt><big>(</big><em>show=None</em>, <em>priority=0</em><big>)</big></dt>
<dd><p>Restores the lights and LEDs from lower priority shows under this
show.</p>
<p>This is only useful if this show is stopped, because otherwise this show
will just immediately override these restored settings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>show</strong> &#8211; The show which will set the priority of the lights you want to
restore.</li>
<li><strong>priority</strong> &#8211; An iteger value of the lights you want to restore.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In both cases it will only restore lights below the priority you pass,
skipping ones that are at the same value.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.run_registered_script">
<tt class="descname">run_registered_script</tt><big>(</big><em>script_name</em>, <em>**kwargs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.run_script">
<tt class="descname">run_script</tt><big>(</big><em>script</em>, <em>lights=None</em>, <em>leds=None</em>, <em>repeat=True</em>, <em>callback=None</em>, <em>key=None</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Runs a light script.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>script</strong> &#8211; A list of dictionaries of script commands. (See below)</li>
<li><strong>lights</strong> &#8211; A light name or list of lights this script will be applied
to.</li>
<li><strong>leds</strong> &#8211; An LED name or a list of LEDs this script will be applied to.</li>
<li><strong>repeat</strong> (<em>bool</em>) &#8211; Whether the script repeats (loops).</li>
<li><strong>callback</strong> &#8211; A method that will be called when this script stops.</li>
<li><strong>key</strong> &#8211; A key that can be used to later stop the light show this script
creates. Typically a unique string. If it&#8217;s not passed, it will
either be the first light name or the first LED name.</li>
<li><strong>**kwargs</strong> &#8211; Since this method just builds a Light Show, you can use
any other Light Show attribute here as well, such as
tocks_per_sec, blend, repeat, num_repeats, etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mpf.system.light_controller.Show" title="mpf.system.light_controller.Show"><tt class="xref py py-class docutils literal"><span class="pre">Show</span></tt></a> object. Since running a script just sets up and
runs a regular Show, run_script returns the Show object.
In most cases you won&#8217;t need this, but it&#8217;s nice if you want to
know exactly which Show was created by this script so you can
stop it later. (See the examples below for usage.)</p>
</td>
</tr>
</tbody>
</table>
<p>Scripts are similar to Shows, except they only apply to single lights
and you can &#8220;attach&#8221; any script to any light. Scripts are used anytime
you want an light to have more than one action. A simple example would
be a flash an light. You would make a script that turned it on (with
your color), then off, repeating forever.</p>
<p>Scripts could be more complex, like cycling through multiple colors,
blinking out secret messages in Morse code, etc.</p>
<p>Interally we actually just take a script and dynamically convert it
into a Show (that just happens to only be for a single light), so
we can have all the other Show-like features, including playback
speed, repeats, blends, callbacks, etc.</p>
<p>The script is a list of dictionaries, with each list item being a
sequential instruction, and the dictionary defining what you want to
do at that step. Dictionary items for each step are:</p>
<blockquote>
<div><p>color: The hex color for the light
time: How long (in ms) you want the light to be at that color
fade: True/False. Whether you want that light to fade to the color</p>
<blockquote>
<div>(using the <em>time</em> above), or whether you want it to switch to
that color instantly.</div></blockquote>
</div></blockquote>
<p>Example usage:</p>
<p>Here&#8217;s how you would use the script to flash an RGB light between red
and off:</p>
<blockquote>
<div><p>self.flash_red = []
self.flash_red.append({&#8220;color&#8221;: &#8216;ff0000&#8217;, &#8216;tocks&#8217;: 1})
self.flash_red.append({&#8220;color&#8221;: &#8216;000000&#8217;, &#8216;tocks&#8217;: 1})
self.machine.show_controller.run_script(script=self.flash_red,</p>
<blockquote>
<div>lights=&#8217;light1&#8217;,
priority=4,
blend=True)</div></blockquote>
</div></blockquote>
<p>Once the &#8220;flash_red&#8221; script is defined as self.flash_red, you can use
it anytime for any light or LED. You can also define lights as a list,
like this:</p>
<blockquote>
<div><dl class="docutils">
<dt>self.machine.show_controller.run_script(script=self.flash_red,</dt>
<dd>lights=[&#8216;light1&#8217;, &#8216;light2&#8217;],
priority=4,
blend=True)</dd>
</dl>
</div></blockquote>
<p>Most likely you would define your scripts once when the game loads and
then call them as needed.</p>
<p>You can also make more complex scripts. For example, here&#8217;s a script
which smoothly cycles an RGB light through all colors of the rainbow:</p>
<blockquote>
<div>self.rainbow = []
self.rainbow.append({&#8216;color&#8217;: &#8216;ff0000&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ff7700&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ffcc00&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;00ff00&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;0000ff&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ff00ff&#8217;, &#8216;tocks&#8217;: 1, &#8216;fade&#8217;: True})</div></blockquote>
<p>If you have single color lights, your <em>color</em> entries in your script
would only contain a single hex value for the intensity of that light.
For example, a script to flash a single-color light on-and-off (which
you can apply to any light):</p>
<blockquote>
<div>self.flash = []
self.flash.append({&#8220;color&#8221;: &#8220;ff&#8221;, &#8220;tocks&#8221;: 1})
self.flash.append({&#8220;color&#8221;: &#8220;00&#8221;, &#8220;tocks&#8221;: 1})</div></blockquote>
<p>If you&#8217;d like to save a reference to the <a class="reference internal" href="#mpf.system.light_controller.Show" title="mpf.system.light_controller.Show"><tt class="xref py py-class docutils literal"><span class="pre">Show</span></tt></a> that&#8217;s
created by this script, call it like this:</p>
<blockquote>
<div><dl class="docutils">
<dt>self.blah = self.machine.show_controller.run_script(&#8220;light2&#8221;,</dt>
<dd>self.flash_red, &#8220;4&#8221;,
tocks_per_sec=2)</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="mpf.system.light_controller.LightController.running_show_keys">
<tt class="descname">running_show_keys</tt><em class="property"> = None</em></dt>
<dd><p>Dict of active light shows that were created from scripts. This is
useful for stopping shows later. Keys are based on the &#8216;key&#8217; parameter
specified when a script was run, values are references to the show
object.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.stop_script">
<tt class="descname">stop_script</tt><big>(</big><em>key</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Stops and removes the light show that was created by a light script.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; The key that was specified in run_script().</li>
<li><strong>**kwargs</strong> &#8211; Not used, included in case this method is called via an
event handler that might contain other random paramters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.stop_show">
<tt class="descname">stop_show</tt><big>(</big><em>show=None</em>, <em>key=None</em>, <em>**kwargs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.stop_shows_by_key">
<tt class="descname">stop_shows_by_key</tt><big>(</big><em>key</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.stop_shows_by_keys">
<tt class="descname">stop_shows_by_keys</tt><big>(</big><em>keys</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.sync_ms_next_tick">
<tt class="descname">sync_ms_next_tick</tt><big>(</big><em>sync_ms</em><big>)</big></dt>
<dd><p>Figures out the next tick show should start based on the passed
sync_ms value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sync_ms</strong> &#8211; Integer of the sync period in ms.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Int of a tick number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.unload_light_player_shows">
<tt class="descname">unload_light_player_shows</tt><big>(</big><em>removal_tuple</em><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpf.system.light_controller.Playlist">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">Playlist</tt><big>(</big><em>machine</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A list of <a class="reference internal" href="#mpf.system.light_controller.Show" title="mpf.system.light_controller.Show"><tt class="xref py py-class docutils literal"><span class="pre">Show</span></tt></a> objects which are then played sequentially.</p>
<p>Playlists are useful for things like attract mode where you play one show
for a few seconds, then another, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>machine</strong> &#8211; The main MachineController object</td>
</tr>
</tbody>
</table>
<p>Each step in a playlist can contain more than one <a class="reference internal" href="#mpf.system.light_controller.Show" title="mpf.system.light_controller.Show"><tt class="xref py py-class docutils literal"><span class="pre">Show</span></tt></a>. This
is useful if you have a lot of little shows for different areas of the
playfield that you want run at the same time. For example, you might have
one show that only controls a group of rollover lane lights, and another
which blinks the lights in the center of the playfield. You can run them at
the by putting them in the same step in your playlist. (Note you don&#8217;t need
to use a playlist if you simply want to run two Shows at the same
time. In that case you could just call <a class="reference internal" href="#mpf.system.light_controller.Show.play" title="mpf.system.light_controller.Show.play"><tt class="xref py py-meth docutils literal"><span class="pre">Show.play()</span></tt></a> twice to play
both shows.</p>
<p>For each &#8220;step&#8221; in the playlist, you can specify the number of seconds it
runs those shows before moving on, or you can specify that one of the shows
in that step plays a certain number of times and then the playlist moves
to the next step from there.</p>
<p>You create a show by creating an instance <a class="reference internal" href="#mpf.system.light_controller.Playlist" title="mpf.system.light_controller.Playlist"><tt class="xref py py-class docutils literal"><span class="pre">Playlist</span></tt></a>. Then you
add Shows to it via <a class="reference internal" href="#mpf.system.light_controller.Playlist.add_show" title="mpf.system.light_controller.Playlist.add_show"><tt class="xref py py-meth docutils literal"><span class="pre">add_show()</span></tt></a>. Finally, you specify the
settings for each step (like how it knows when to move on) via :meth:
<cite>step_settings</cite>.</p>
<p>When you start a playlist (via <a class="reference internal" href="#mpf.system.light_controller.Playlist.start" title="mpf.system.light_controller.Playlist.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a>, you can specify
settings like what priority the show runs at, whether it repeats, etc.)</p>
<p>Example usage from a game mode:
(This example assumes we have self.show1, self.show2, and self.show3
already loaded.)</p>
<p>Setup the playlist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span> <span class="o">=</span> <span class="n">lights</span><span class="o">.</span><span class="n">Playlist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">machine</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show1</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show2</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show3</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Run the playlist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Stop the playlist:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">self.my_playlist.stop()</span></tt></div></blockquote>
<dl class="method">
<dt id="mpf.system.light_controller.Playlist.add_show">
<tt class="descname">add_show</tt><big>(</big><em>step_num</em>, <em>show</em>, <em>num_repeats=0</em>, <em>tocks_per_sec=32</em>, <em>blend=False</em>, <em>repeat=True</em><big>)</big></dt>
<dd><p>Adds a Show to this playlist. You have to add at least one show
before you start playing the playlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_num</strong> &#8211; Interger of which step number you&#8217;re adding this show to.
You have to specify this since it&#8217;s possible to add multiple
shows to the same step (in cases where you want them both to
play at the same time during that step). If you want the same
show to play in multiple steps, then add it multiple times (once
to each step). The show plays starting with the lowest number
step and then moving on. Ideally they&#8217;d be 1, 2, 3... but it
doesn&#8217;t matter. If you have step numbers of 1, 2, 5... then the
player will figure it out.</li>
<li><strong>show</strong> &#8211; The Show object that you&#8217;re adding to this step.</li>
<li><strong>num_repeats</strong> &#8211; Integer of how many times you want this show to repeat
within this step. Note this does not affect when the playlist
advances to the next step. (That is controlled via
<a class="reference internal" href="#mpf.system.light_controller.Playlist.step_settings" title="mpf.system.light_controller.Playlist.step_settings"><tt class="xref py py-meth docutils literal"><span class="pre">step_settings()</span></tt></a>.) Rather, this is just how many loops this
show plays. A value of 0 means it repeats indefinitely. (Well,
until the playlist advances to the next step.) Note that you
also have to have repeat=True for it to repeat here.</li>
<li><strong>tocks_per_sec</strong> &#8211; Integer of how fast you want this show to play. See
<a class="reference internal" href="#mpf.system.light_controller.Show.play" title="mpf.system.light_controller.Show.play"><tt class="xref py py-meth docutils literal"><span class="pre">Show.play()</span></tt></a> for details.</li>
<li><strong>blend</strong> &#8211; Boolean of whether you want this show to blend with lower
priority shows below it. See <a class="reference internal" href="#mpf.system.light_controller.Show.play" title="mpf.system.light_controller.Show.play"><tt class="xref py py-meth docutils literal"><span class="pre">Show.play()</span></tt></a> for details.</li>
<li><strong>repeat</strong> &#8211; Boolean which causes the show to keep repeating until the
playlist moves on to the next step.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.start">
<tt class="descname">start</tt><big>(</big><em>priority=0</em>, <em>repeat=True</em>, <em>repeat_count=0</em>, <em>reset=True</em><big>)</big></dt>
<dd><p>Starts playing a playlist. You can only use this after you&#8217;ve added
at least one show via <a class="reference internal" href="#mpf.system.light_controller.Playlist.add_show" title="mpf.system.light_controller.Playlist.add_show"><tt class="xref py py-meth docutils literal"><span class="pre">add_show()</span></tt></a> and configured the settings for
each step via <a class="reference internal" href="#mpf.system.light_controller.Playlist.step_settings" title="mpf.system.light_controller.Playlist.step_settings"><tt class="xref py py-meth docutils literal"><span class="pre">step_settings()</span></tt></a>.</p>
<p>Args</p>
<dl class="docutils">
<dt>priority: Integer of what priority you want the <a class="reference internal" href="#mpf.system.light_controller.Show" title="mpf.system.light_controller.Show"><tt class="xref py py-class docutils literal"><span class="pre">Show</span></tt></a> shows in</dt>
<dd>this playlist to play at. These shows will play &#8220;on top&#8221; of
lower priority stuff, but &#8220;under&#8221; higher priority things.</dd>
</dl>
<p>repeat: Controls whether this playlist to repeats when it&#8217;s finished.
repeat_count: How many times you want this playlist to</p>
<blockquote>
<div>repeat before it stops itself. (Must be used with <em>repeat=True</em> above.)
A value of 0 here means that this playlist repeats forever until you
manually stop it. (This is ideal for attract mode.)</div></blockquote>
<dl class="docutils">
<dt>reset: Boolean which controls whether you want this playlist to</dt>
<dd>start at the begining (True) or you want it to pick up where it left
off (False). You can also use <em>reset</em> to restart a playlist that&#8217;s
currently running.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.step_settings">
<tt class="descname">step_settings</tt><big>(</big><em>step</em>, <em>time=0</em>, <em>trigger_show=None</em>, <em>hold=False</em><big>)</big></dt>
<dd><p>Used to configure the settings for a step in a <a class="reference internal" href="#mpf.system.light_controller.Playlist" title="mpf.system.light_controller.Playlist"><tt class="xref py py-class docutils literal"><span class="pre">Playlist</span></tt></a>.
This configuration is required for each step. The main thing you use
this for is to specify how the playlist knows to move on to the next
step.</p>
<p>Args:</p>
<p>step: Integer for which step number you&#8217;re configuring
time: Integer of the time in seconds that you want this step to run</p>
<blockquote>
<div>before moving on to the next one.</div></blockquote>
<dl class="docutils">
<dt>trigger_show: If you want to move to the next step after</dt>
<dd>one of the Shows in this step is done playing, pass that show&#8217;s object
here. This is required because if there are multiple
Shows in this step of the playlist which all end at different
times, we wouldn&#8217;t know which one to watch in order to know when to
move on.</dd>
</dl>
<p>Note that you can have repeats with a trigger show, but in that case
you also need to have the num_repeats specified. Otherwise if you have
your trigger show repeating forever then the playlist will never move
on. (In that case use the <em>time</em> parameter to move on based on time.)</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.stop">
<tt class="descname">stop</tt><big>(</big><em>reset=True</em>, <em>hold=None</em><big>)</big></dt>
<dd><p>Stops a playlist. Pretty simple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reset</strong> &#8211; If <em>True</em>, it resets the playlist tracking counter back to
the beginning. You can use <em>False</em> here if you want to stop and
then restart a playlist to pick up where it left off.</li>
<li><strong>hold</strong> &#8211; Boolean which specifies whether this playlist should should
hold the lights and LEDs in their current states. Default is
None which means it inherits whatever the shows or playlist
settings were, but you can force it True or False if you want
here.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpf.system.light_controller.Show">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">Show</tt><big>(</big><em>machine</em>, <em>config</em>, <em>file_name</em>, <em>asset_manager</em>, <em>actions=None</em><big>)</big></dt>
<dd><p>Bases: <a class="reference internal" href="mpf.system.assets.html#mpf.system.assets.Asset" title="mpf.system.assets.Asset"><tt class="xref py py-class docutils literal"><span class="pre">mpf.system.assets.Asset</span></tt></a></p>
<dl class="method">
<dt id="mpf.system.light_controller.Show.add_loaded_callback">
<tt class="descname">add_loaded_callback</tt><big>(</big><em>loaded_callback</em>, <em>**kwargs</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Show.change_speed">
<tt class="descname">change_speed</tt><big>(</big><em>tocks_per_sec=1</em><big>)</big></dt>
<dd><p>Changes the playback speed of a running Show.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tocks_per_sec</strong> &#8211; The new tocks_per_second play rate.</td>
</tr>
</tbody>
</table>
<p>If you want to change the playback speed by a percentage, you can
access the current tocks_per_second rate via Show&#8217;s
tocks_per_second variable. So if you want to double the playback speed
of your show, you could do something like:</p>
<blockquote>
<div>self.your_show.change_speed(self.your_show.tocks_per_second*2)</div></blockquote>
<p>Note that you can&#8217;t just update the show&#8217;s tocks_per_second directly
because we also need to update self.ticks_per_tock.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Show.load_show_from_disk">
<tt class="descname">load_show_from_disk</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Show.play">
<tt class="descname">play</tt><big>(</big><em>repeat=False</em>, <em>priority=0</em>, <em>blend=False</em>, <em>hold=None</em>, <em>tocks_per_sec=30</em>, <em>start_location=None</em>, <em>callback=None</em>, <em>num_repeats=0</em>, <em>sync_ms=0</em>, <em>reset=True</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Plays a Show. There are many parameters you can use here which
affect how the show is played. This includes things like the playback
speed, priority, whether this show blends with others, etc. These are
all set when the show plays. (For example, you could have a Show
file which lights a bunch of lights sequentially in a circle pattern,
but you can have that circle &#8220;spin&#8221; as fast as you want depending on
how you play the show.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>repeat</strong> &#8211; Boolean of whether the show repeats when it&#8217;s done.</li>
<li><strong>priority</strong> &#8211; Integer value of the relative priority of this show. If
there&#8217;s ever a situation where multiple shows want to control
the same item, the one with the higher priority will win.
(&#8220;Higher&#8221; means a bigger number, so a show with priority 2 will
override a priority 1.)</li>
<li><strong>blend</strong> &#8211; Boolean which controls whether this show &#8220;blends&#8221; with lower
priority shows and scripts. For example, if this show turns a
light off, but a lower priority show has that light set to blue,
then the light will &#8220;show through&#8221; as blue while it&#8217;s off here.
If you don&#8217;t want that behavior, set blend to be False. Then off
here will be off for sure (unless there&#8217;s a higher priority show
or command that turns the light on). Note that not all item
types blend. (You can&#8217;t blend a coil or event, for example.)</li>
<li><strong>hold</strong> &#8211; Boolean which controls whether the lights or LEDs remain in
their final show state when the show ends. Default is None which
means hold will be False if the show has more than one step, and
True if there is only one step.</li>
<li><strong>tocks_per_sec</strong> &#8211; Integer of how fast your show runs (&#8220;Playback speed,&#8221;
in other words.) Your Show files specify action times in terms
of &#8216;tocks&#8217;, like &#8220;make this light red for 3 tocks, then off for
4 tocks, then a different light on for 6 tocks. When you play a
show, you specify how many tocks per second you want it to play.
Default is 30, but you might even want tocks_per_sec of only 1
or 2 if your show doesn&#8217;t need to move than fast. Note this does
not affect fade rates. So you can have tocks_per_sec of 1 but
still have lights fade on and off at whatever rate you want.
Also the term &#8220;tocks&#8221; was chosen so as not to confuse it with
&#8220;ticks&#8221; which is used by the machine run loop.</li>
<li><strong>start_location</strong> &#8211; Integer of which position in the show file the show
should start in. Usually this is 0 but it&#8217;s nice to start part
way through. Also used for restarting shows that you paused. A
negative value will count backwards from the end (-1 is the last
position, -2 is second to last, etc.).</li>
<li><strong>callback</strong> &#8211; A callback function that is invoked when the show is
stopped.</li>
<li><strong>num_repeats</strong> &#8211; Integer of how many times you want this show to repeat
before stopping. A value of 0 means that it repeats
indefinitely. Note this only works if you also have repeat=True.</li>
<li><strong>sync_ms</strong> &#8211; Number of ms of the show sync cycle. A value of zero means
this show will also start playing immediately. See the full MPF
documentation for details on how this works.</li>
<li><strong>reset</strong> &#8211; Boolean which controls whether this show will reset to its
first position once it ends. Default is True.</li>
<li><strong>**kwargs</strong> &#8211; Not used, but included in case this method is used as an
event handler which might include additional kwargs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Show.resync">
<tt class="descname">resync</tt><big>(</big><big>)</big></dt>
<dd><p>Causes this show to do a one-time update to resync all the LEDs and
lights in the show with where they should be now. This is used when a
higher priority show stops so lower priority shows can put all the
lights back to how they want them.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Show.stop">
<tt class="descname">stop</tt><big>(</big><em>reset=True</em>, <em>hold=None</em><big>)</big></dt>
<dd><p>Stops the Light Show.</p>
<p>Note you can also use this method to clear a stopped show&#8217;s held lights
and LEDs by passing hold=False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reset</strong> &#8211; Boolean which controls whether the show will reset its
current position back to zero. Default is True.</li>
<li><strong>hold</strong> &#8211; Boolean which controls whether the show will hold its current
lights and LEDs in whatever state they are now, including their
priorities. Default is None which will just use whatever the
show setting was when you played it, but you can force it to
hold or not with True or False here.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="mpf.system.events.html"
                        title="previous chapter">mpf.system.events module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mpf.system.logic_blocks.html"
                        title="next chapter">mpf.system.logic_blocks module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/mpf.system.light_controller.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mpf.system.logic_blocks.html" title="mpf.system.logic_blocks module"
             >next</a> |</li>
        <li class="right" >
          <a href="mpf.system.events.html" title="mpf.system.events module"
             >previous</a> |</li>
        <li><a href="mpf.html">Mission Pinball Framework 0.20.0-a0 documentation</a> &raquo;</li>
          <li><a href="mpf.system.html" >mpf.system package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Brian Madden, Gabe Knuth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>